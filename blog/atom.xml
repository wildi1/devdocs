<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Shopware Developers]]></title>
    <link href="https://developers.shopware.com/atom.xml" rel="self"/>
    <link href="https://developers.shopware.com/"/>
    <updated>2017-07-31T11:16:56+00:00</updated>
    <id>https://developers.shopware.com/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
        <entry>
        <title type="html"><![CDATA[SEO URLs in plugins]]></title>
        <link href="https://developers.shopware.com/blog/2017/07/24/seo-urls-in-plugins"/>
        <updated>2017-07-24T00:00:00+00:00</updated>
        <id>https://developers.shopware.com/blog/2017/07/24/seo-urls-in-plugins</id>
        <content type="html"><![CDATA[<p>In the world of eCommerce, SEO is a very important and recurrent topic.
Thus, Shopware offers some tools to create a SEO friendly shop by default, including SEO friendly URLs.
Make sure to have a look at the following SEO blog post, covering detailed information for the Shopware SEO engine: <a href="/blog/2015/08/11/the-shopware-seo-engine/">The Shopware SEO engine</a></p>

<p>But for now, how do we actually create proper SEO URLs for our custom plugins?</p>

<p>It must have been about a year ago when I stumbled across the same issue while reworking our premium plugin
<a href="http://store.shopware.com/en/swagproductadvisor/shopping-advisor.html">Shopping advisor</a>.</p>

<p>In this blog post, I want to provide a short tutorial on how to implement custom SEO URLs for your plugins.
I'll also attach an example plugin for both Shopware 5.3 and 5.2 at the end of the tutorial.</p>

<h2>Generating a SEO URL for a custom controller</h2>

<p>For this short tutorial I will use a very basic plugin based on the new plugin system.</p>

<h3>The scenario</h3>

<p>As an example, I would like to create a glossary plugin.</p>

<p>Using the glossary plugin, the shop owner should be able to create a description for a word.
The plugin will provide an overview, showing all given words and their description.</p>

<p>To store those, I created a table with the name <code>s_glossary</code> and the columns <code>id</code>, <code>word</code> and <code>description</code>.</p>

<p>Later in this tutorial we also want to add a detail page, only showing a given word and its respective description.</p>

<p>Let's assume the basic plugin structure contains a registered Frontend controller called <code>Glossary</code>, as well as the mentioned
database table.</p>

<h3>Let's get started</h3>

<p>For the glossary overview, we would implement an <code>indexAction</code> in our <code>Glossary</code> controller to handle the overview.
In order to call our action now, we'd open the following URL: <code>http://myShop.com/glossary/</code></p>

<p>That URL looks smooth and SEO friendly already, doesn't it?</p>

<p>What happens, if we want the glossary page to be internationally available?
For your german customers, you would want the glossary to be available using <code>http://myShop.com/glossar/</code> as well.</p>

<p>This can and should be done using SEO URLs.</p>

<p>First of all, SEO URLs in Shopware are stored in the database table <code>s_core_rewrite_urls</code>.
We could just create a new entry in that table during the installation process of the plugin.
That would actually work for now.</p>

<p>Yet, we want to create those SEO URLs depending on the 'refresh strategies' configuration.</p>

<p>This configuration can be found in the backend: <code>Configuration &gt; Cache/performance &gt; Settings &gt; SEO &gt; Refresh strategy</code>.
Our SEO URLs are generated in three different ways, being configurable in the backend.</p>

<p>Available options are:</p>

<ul>
<li>Manually</li>
<li>Via cronjob</li>
<li>Live</li>
</ul>

<p>Again, refer to this blog post to get more detailed information on how those work: <a href="/blog/2015/08/11/the-shopware-seo-engine/">The Shopware SEO engine</a></p>

<p>As each of the options mentioned above requires slightly different plugin logic, I'll explain them step by step.</p>

<h3>Implement logic for 'Via cronjob'</h3>

<div class="alert alert-danger" role="error">
    The following code is only compatible with Shopware version 5.3 or higher.
</div>

<p>In <strong>Shopware 5.3</strong> we implemented a new event to SEO URL generation using the cronjob. <br />
Everytime the cronjob <code>RefreshSeoIndex</code> is triggered, the method <code>onRefreshSeoIndex</code> in <a href="https://github.com/shopware/shopware/blob/5.3/engine/Shopware/Plugins/Default/Core/RebuildIndex/Bootstrap.php#L134">engine/Shopware/Plugins/Default/Core/RebuildIndex/Bootstrap.php</a> is called. <br />
It now contains a new notify event called <code>Shopware_CronJob_RefreshSeoIndex_CreateRewriteTable</code>, which we will use to add our own SEO URL generation process.
The event is called once for each shop after every other SEO URL (e.g. Products, Categories, ...) has been generated for this shop.</p>

<pre><code>public static function getSubscribedEvents()
{
    return [
        'Shopware_CronJob_RefreshSeoIndex_CreateRewriteTable' =&gt; 'createGlossaryRewriteTable'
    ];
}

public function createGlossaryRewriteTable()
{
    /** @var \sRewriteTable $rewriteTableModule */
    $rewriteTableModule = Shopware()-&gt;Container()-&gt;get('modules')-&gt;sRewriteTable();
    
    // Insert new rewrite URL for our custom controller
    $rewriteTableModule-&gt;sInsertUrl('sViewport=glossary', 'glossary/');
}
</code></pre>

<p>In the example mentioned above, we would create a new rewrite URL for each shop.
Of course, in this code we could and should now build our logic to create the translated rewrite URLs, e.g. <code>http://myShop.com/glossar</code>, which would be the german translation for it.</p>

<h3>Implement logic for 'Live'</h3>

<p>This option does <strong>not</strong> mean, that with each and every request the SEO URLs are re-generated.
You can configure the refresh interval in the backend under <code>Configuration &gt; Cache/performance &gt; Settings &gt; SEO &gt; Refresh strategy</code>.</p>

<p>Basically, whenever a request is sent to the shop and the response is about to be sent back, Shopware checks if it's time to re-generate the SEO URLs.
In only that case (refresh strategy is 'live' AND the interval has passed), the method <code>sCreateRewriteTable</code> from our core module <a href="https://github.com/shopware/shopware/blob/5.3/engine/Shopware/Core/sRewriteTable.php#L220">sRewriteTable</a> is called.</p>

<p>This method only generates the SEO URLs for the <strong>currently</strong> active shop.</p>

<p>Therefore we could use an after hook on the method mentioned above.
The code to actually insert our URL into the database is the same, so we can just re-use the same code with a different event.</p>

<pre><code>public static function getSubscribedEvents()
{
    return [
        'Shopware_CronJob_RefreshSeoIndex_CreateRewriteTable' =&gt; 'createGlossaryRewriteTable',
        'sRewriteTable::sCreateRewriteTable::after' =&gt; 'createGlossaryRewriteTable',
    ];
}

public function createGlossaryRewriteTable()
{
    /** @var \sRewriteTable $rewriteTableModule */
    $rewriteTableModule = Shopware()-&gt;Container()-&gt;get('modules')-&gt;sRewriteTable();
    $rewriteTableModule-&gt;sInsertUrl('sViewport=glossary', 'glossary/');
}
</code></pre>

<p>That's it for the live mode.</p>

<h3>Implement logic for 'Manual'</h3>

<div class="alert alert-danger" role="error">
    The following code is only compatible with Shopware version 5.3 or higher.
</div>

<div class="is-float-right">
    <img alt="Overview of the SEO URL concept" src="/blog/img/manual-seo-generation-win.png">
    <div><em>The manual SEO URL generation window</em></div>
</div>

<p>This is where things become a little tricky.
The manual URL generation is actually handled in ExtJs, generating the URLs in a batch mode.</p>

<p>You can choose a batch size, which defines how many URLs should be generated with each request.</p>

<p>We want to have our own progress bar at the bottom of the window now to generate our SEO URLs for the currently selected shop in batch mode.</p>

<p>First of all we have to extend the file <a href="https://github.com/shopware/shopware/blob/5.3/themes/Backend/ExtJs/backend/performance/view/main/multi_request_tasks.js#L83">themes/Backend/ExtJs/backend/performance/view/main/multi_request_tasks.js</a>.
We have to extend the property 'seo', which contains all progress bars, their snippets and, most important, the request URL to be called for each batch call to generate the SEO URLs.</p>

<p>So, let's overwrite the ExtJs window.
I won't go into detail on how to extend an ExtJs file. Refer to this guide about <a href="/developers-guide/backend-extension/#example-#1:-simple-extension">extending the backend</a> instead.</p>

<p><em>Register new event:</em></p>

<pre><code>public static function getSubscribedEvents()
{
    return [
        ...
        'Enlight_Controller_Action_PostDispatch_Backend_Performance' =&gt; 'loadPerformanceExtension'
    ];
}
</code></pre>

<p><br /></p>

<p><em>The respective listener:</em></p>

<pre><code>public function loadPerformanceExtension(\Enlight_Controller_ActionEventArgs $args)
{
    $subject = $args-&gt;getSubject();
    $request = $subject-&gt;Request();

    if ($request-&gt;getActionName() !== 'load') {
        return;
    }

    $subject-&gt;View()-&gt;addTemplateDir(__DIR__ . '/Resources/views/');
    $subject-&gt;View()-&gt;extendsTemplate('backend/performance/view/glossary.js');
}
</code></pre>

<p>With Shopware 5.3 we implemented a new method called <code>addProgressBar</code> to <code>multi_request_tasks.js</code>.
As the first parameter you have to provide an object containing an 'initialText' to be shown initially, a 'progressText' to be shown while generating the SEO URLs
and a 'requestUrl' to be called with each step in the batch processing.
The second parameter has to be a name for the new progress bar - we need this one later.
The third parameter should be the target. Possible values are 'seo' and 'httpCache'. As we want to create a new progress bar to the SEO window, we'll use 'seo' here obviously.</p>

<pre><code>//{block name=&quot;backend/performance/view/main/multi_request_tasks&quot; append}
Ext.define('Shopware.apps.Performance.view.main.Glossary', {
    override: 'Shopware.apps.Performance.view.main.MultiRequestTasks',

    initComponent: function() {
        this.addProgressBar(
            {
                initialText: 'Glossary URLs',
                progressText: '[0] of [1] glossary URLs',
                requestUrl: '{url controller=glossary action=generateSeoUrl}'
            },
            'glossary',
            'seo'
        );

        this.callParent(arguments);
    }
});
//{/block}
</code></pre>

<p>Once we refresh the backend and probably clear the cache, the SEO window should now contain our new progress bar.
Now we need to create our backend controller and a <code>generateSeoUrlAction</code>.</p>

<p>With each AJAX request for the batch processing, we'll get a shopId, an offset and a limit to properly generate our SEO URLs.
We can ignore offset and the limit <strong>for the moment</strong>, since there is only a single URL to be generated for each shop.
Just remember them for later in this tutorial.</p>

<p><em>Controllers/Backend/Glossary.php</em></p>

<pre><code>&lt;?php

class Shopware_Controllers_Backend_Glossary extends Shopware_Controllers_Backend_ExtJs
{
    public function generateSeoUrlAction()
    {
        $shopId = $this-&gt;Request()-&gt;getParam('shopId');

        /** @var Shopware_Components_SeoIndex $seoIndex */
        $seoIndex = $this-&gt;container-&gt;get('SeoIndex');
        $seoIndex-&gt;registerShop($shopId);

        /** @var sRewriteTable $rewriteTableModule */
        $rewriteTableModule = $this-&gt;container-&gt;get('modules')-&gt;RewriteTable();
        $rewriteTableModule-&gt;baseSetup();
        $rewriteTableModule-&gt;sInsertUrl('sViewport=glossary', 'glossary/');

        $this-&gt;View()-&gt;assign(['success' =&gt; true]);
    }
}
</code></pre>

<p>We're fetching the shopId, register a shop using the given shopId and then simply insert our rewrite URL again.</p>

<p>Now there's one more thing missing.
Once we select a shop in the backend SEO module, an AJAX call is sent to collect the total counts of URLs to be created with each progress bar.
Our glossary URLs are not collected yet, so the module can't handle our glossary URLs properly yet.</p>

<p>To collect the URLs, the <code>getCountAction</code> of the <a href="https://github.com/shopware/shopware/blob/5.3/engine/Shopware/Plugins/Default/Core/RebuildIndex/Controllers/Seo.php#L72">SEO controller</a> is called.
Thankfully it provides a filter event <code>Shopware_Controllers_Seo_filterCounts</code> to properly add our own counts. For this we need to use the name we used earlier for the progress bar.</p>

<pre><code>public static function getSubscribedEvents()
{
    return [
        ...
        'Shopware_Controllers_Seo_filterCounts' =&gt; 'addGlossaryCount'
    ];
}

public function addGlossaryCount(\Enlight_Event_EventArgs $args)
{
    $counts = $args-&gt;getReturn();

    $counts['glossary'] = 1;

    return $counts;
}
</code></pre>

<p>Currently, there's only a single URL to be generated for each shop, so we'll just return a static 1.</p>

<p>So, now let's try it.
If you've implemented everything properly, it should work perfectly now.</p>

<h2>Custom parameters in SEO URL</h2>

<p>Now we've implemented a simple SEO URL generation for our glossary plugin.
The overview is now supported by SEO friendly URLs and we even generate those URLs in a proper way, depending on the given configuration.</p>

<p>Now we want to have some kind of &quot;detail&quot; page for each word.
When calling this detailed page, we only see a single word with its related description.</p>

<p>For this we need a new action in our <strong>Frontend</strong> Controller, e.g. &quot;detailAction&quot;.
We could call this action by using an URL like <code>http://myShop.com/glossary/detail</code>.
In this case though, we would have to attach an ID for the word we want to show now.</p>

<p>Sounds easy, let's just attach it to the URL:
<code>http://myShop.com/glossary/detail?wordId=1</code></p>

<p>This link would now display the word with the ID 1.
Wouldn't it be cooler to have the word itself as a part of the URL now?
E.g. you'd want to explain the word 'recursion', then the URL could look like this: <code>http://myShop.com/glossary/recursion</code></p>

<p>Way better, isn't it?</p>

<p>Now this already requires several changes in our code.
First of all, every time we generate our SEO URLs, we have to iterate through all words in our database.</p>

<pre><code>public function createGlossaryRewriteTable()
{
    /** @var \sRewriteTable $rewriteTableModule */
    $rewriteTableModule = Shopware()-&gt;Container()-&gt;get('modules')-&gt;sRewriteTable();
    $rewriteTableModule-&gt;sInsertUrl('sViewport=glossary', 'glossary/');

    /** @var QueryBuilder $dbalQueryBuilder */
    $dbalQueryBuilder = $this-&gt;container-&gt;get('dbal_connection')-&gt;createQueryBuilder();

    $words = $dbalQueryBuilder-&gt;select('glossary.id, glossary.word')
        -&gt;from('s_glossary', 'glossary')
        -&gt;execute()
        -&gt;fetchAll(\PDO::FETCH_KEY_PAIR);

    foreach ($words as $wordId =&gt; $word) {
        $rewriteTableModule-&gt;sInsertUrl('sViewport=glossary&amp;sAction=detail&amp;wordId=' . $wordId, 'glossary/' . $word);
    }
}
</code></pre>

<p>Also, we need to adjust the URL counts for the backend now.</p>

<pre><code>public function addGlossaryCount(\Enlight_Event_EventArgs $args)
{
    $counts = $args-&gt;getReturn();

    /** @var QueryBuilder $dbalQueryBuilder */
    $dbalQueryBuilder = $this-&gt;container-&gt;get('dbal_connection')-&gt;createQueryBuilder();
    $wordsCount = $dbalQueryBuilder-&gt;select('COUNT(glossary.id)')
        -&gt;from('s_glossary', 'glossary')
        -&gt;execute()
        -&gt;fetchAll(\PDO::FETCH_COLUMN);

    $counts['glossary'] = $wordsCount;

    return $counts;
}
</code></pre>

<p>Do you still remember the <code>offset</code> and the <code>limit</code> parameter from the batch processing for the SEO URLs?
Now we do have to implement those, to only generate as many SEO URLs as configured in the batch process.</p>

<pre><code>public function generateSeoUrlAction()
{
    ...

    /** @var QueryBuilder $dbalQueryBuilder */
    $dbalQueryBuilder = $this-&gt;container-&gt;get('dbal_connection')-&gt;createQueryBuilder();
    $words = $dbalQueryBuilder-&gt;select('glossary.id, glossary.word')
        -&gt;from('s_glossary', 'glossary')
        -&gt;setMaxResults($limit)
        -&gt;setFirstResult($offset)
        -&gt;execute()
        -&gt;fetchAll(\PDO::FETCH_KEY_PAIR);

    foreach ($words as $wordId =&gt; $word) {
        $rewriteTableModule-&gt;sInsertUrl('sViewport=glossary&amp;sAction=detail&amp;wordId=' . $wordId, 'glossary/' . $word);
    }

    $this-&gt;View()-&gt;assign(['success' =&gt; true]);
}
</code></pre>

<h3>Add foreign parameters</h3>

<p>While this already looks good, there's one more thing to do.
Shopware needs to know our custom parameter &quot;<strong>wordId</strong>&quot; first.
Otherwise our parameter would just get stripped and our SEO URL wouldn't work.</p>

<p>The possible cases for parameters are handled in the <a href="https://github.com/shopware/shopware/blob/5.3/engine/Shopware/Components/Routing/Generators/RewriteGenerator.php#L166">RewriteGenerator</a>.
It has a whole lot of cases, e.g. the parameter &quot;<strong>sArticle</strong>&quot; is only allowed when used with the <strong>detail</strong> controller.</p>

<p>Thankfully, since Shopware 5.2, this method provides an event to add custom parameters.</p>

<p>So, let's add the event and implement our custom parameter.</p>

<pre><code>public static function getSubscribedEvents()
{
    return [
        ...
        'Shopware_Components_RewriteGenerator_FilterQuery' =&gt; 'filterParameterQuery'
    ];
}
</code></pre>

<pre><code>public function filterParameterQuery(\Enlight_Event_EventArgs $args)
{
    $orgQuery = $args-&gt;getReturn();
    $query = $args-&gt;getQuery();

    if ($query['controller'] === 'glossary' &amp;&amp; isset($query['wordId'])) {
        $orgQuery['wordId'] = $query['wordId'];
    }

    return $orgQuery;
}
</code></pre>

<p>So, what did I do here?
First of all, Shopware doesn't know things like &quot;controllers&quot; or &quot;actions&quot; like that.
Due to legacy reasons, Shopware still needs them to be handled as 'sViewport', which would be the controller, and 'sAction',
which obviously represents action.
That's what <code>$orgQuery</code> contains: The controller mapped to 'sViewport' and the action mapped to the array element 'sAction'.
Since <code>$orgQuery</code> will be used for assembling our SEO URL later, we need to add our parameter to it.</p>

<p>Meanwhile, <code>$query</code> contains the actual request parameters as we know them.</p>

<p>We only need to add our custom parameter <code>wordId</code> if both the controller equals 'glossary' and the parameter itself is set.
In that case, we add <code>wordId</code> to <code>$orgQuery</code> and return it afterwards.</p>

<h2>Example plugin</h2>

<p>You can find the example plugin for <strong>Shopware 5.3</strong> <a href="https://developers.shopware.com/exampleplugins/SeoExample.zip">here</a>.</p>

<p>Just to make sure: <strong>This is not a fully functional plugin as it is only supposed to be an example.</strong>
It will create the necessary plugin table <em>s_glossary</em> with a few example words.
This plugin does not provide a backend module to work with and the frontend templates are very slim to show the basic functionality.</p>

<h3>Shopware 5.2 plugin</h3>

<p>We've also created an example plugin for <strong>Shopware 5.2</strong>, which can be found <a href="https://developers.shopware.com/exampleplugins/SeoExample52.zip">here</a>.</p>

<p>There's several differences, e.g. the whole <em>Resources/views/backend</em> directory is different.
Additional to that, the logic to count the available glossary URLs had to be changed, since the event we used above was implemented with 5.3.</p>
]]></content>
    </entry>
        <entry>
        <title type="html"><![CDATA[Quick Tip: Shopping worlds without AJAX]]></title>
        <link href="https://developers.shopware.com/blog/2017/06/26/quick-tip-shopping-worlds-without-ajax"/>
        <updated>2017-06-26T00:00:00+00:00</updated>
        <id>https://developers.shopware.com/blog/2017/06/26/quick-tip-shopping-worlds-without-ajax</id>
        <content type="html"><![CDATA[<p>Today we're back with a short &amp; simple tip which allows you to load shopping worlds at any place in your store front without the need of loading them using AJAX. Do to so, please create your own frontend theme, if you haven't one in place already. Please refer to our <a href="https://developers.shopware.com/designers-guide/getting-started/#custom-themes">Templating Getting Started Guide</a> on how to create your own custom theme.</p>

<p>After creating your own theme, please create a new JavaScript file in your <code>_public/src/js</code> directory &amp; place the following content into it:</p>

<pre><code>window.StateManager
    .removePlugin('.emotion--wrapper', 'swEmotionLoader')
    .addPlugin('.emotion--wrapper:not(.emotion--non-ajax)', 'swEmotionLoader')
    .addPlugin('.emotion--non-ajax *[data-emotion=&quot;true&quot;]', 'swEmotion');
</code></pre>

<p>We're removing the <code>swEmotionLoader</code> jQuery plugin which is the entry point for an AJAX shopping world. We're removing it because we have to modify the selector for the jQuery plugin. In the next line we're adding the same plugin but with a different selector. The selector allows us to add the class <code>emotion--non-ajax</code> to the element which should contain the shopping world later on. Last but not least, we're adding the jQuery plugin <code>swEmotion</code> to the plugin queue with our <code>emotion--non-ajax</code> class in place.</p>

<p>After you've added the content to the JavaScript file, make sure you've registered the file in the <code>$javascript</code> array in your <code>Theme.php</code> file. If you need further information, please head over to our <a href="https://developers.shopware.com/designers-guide/css-and-js-files-usage/#add-javascript-files">CSS &amp; JS Files Usage Guide</a>.</p>

<p>With these changes in place, you're now able to include shopping worlds literally at any place in your store front with the following code snippet:</p>

<pre><code>&lt;div class=&quot;emotion--wrapper emotion--non-ajax&quot;&gt;
    {action module=&quot;widgets&quot; controller=&quot;emotion&quot; action=&quot;index&quot; emotionId=&quot;7&quot;}
&lt;/div&gt;
</code></pre>

<p>The argument <code>emotionId</code> in the widget call lets you choose what shopping world you would like to include. To get an overview of all available shopping worlds, please refer to the <code>s_core_emotion</code> database table.</p>

<p>You may have to customize the styling of the shopping world, depending on what section of the store front you're using it.</p>
]]></content>
    </entry>
        <entry>
        <title type="html"><![CDATA[Call for papers: Shopware Community Day 2017]]></title>
        <link href="https://developers.shopware.com/blog/2017/03/14/call-for-papers-shopware-community-day-2017"/>
        <updated>2017-03-14T00:00:00+00:00</updated>
        <id>https://developers.shopware.com/blog/2017/03/14/call-for-papers-shopware-community-day-2017</id>
        <content type="html"><![CDATA[<p><a href="https://cfp.shopware.com/"><img src="/blog/img/cfp-scd-2017.png" alt="image" /></a></p>

<p>The <a href="https://scd.shopware.com/">Shopware Community Day</a> is on June 09, and we are looking forward to hear about your <a href="https://cfp.shopware.com/">idea for a talk</a>!</p>

<p>Whatever you want to tell or show the shopware community, don't hesitate to submit your talk. Whatever it is, we will have a look into it.</p>

<p>See you there! :)</p>
]]></content>
    </entry>
        <entry>
        <title type="html"><![CDATA[Currency formatting is easy, isn&#039;t it?]]></title>
        <link href="https://developers.shopware.com/blog/2017/02/06/currency-formatting-is-easy-isnt-it"/>
        <updated>2017-02-06T00:00:00+00:00</updated>
        <id>https://developers.shopware.com/blog/2017/02/06/currency-formatting-is-easy-isnt-it</id>
        <content type="html"><![CDATA[<p>I stumbled across a quite common problem in eCommerce projects I would like to cover in this blog post. According to a
popular saying &quot;Money is what makes the world go round&quot; do we have to deal with currencies all the time especially in an application with heavy
client side processing and templating. You're always using a formatter or helper methods in some way or another to deal with currencies. All
of these solutions are not feeling right.</p>

<h3>What's the problem anyways?</h3>

<p>Let's take a look at one of those functions to get a feeling for the situation we're facing. One of the simplest ways
is to have a function like this in place:</p>

<pre><code>function formatCurrency (val) {
    return val.toString().replace('.', ',') + ' €';
}
</code></pre>

<p><em>Very simple example for a currency formatter function</em></p>

<p>As you can tell already, it just covers one specific currency format. If we're dealing with prices in any other currency
like USD for example, the helper fails miserably. So what we can do is extend the method to provide us with the ability
to support multiple currencies?</p>

<pre><code>function formatCurrency (val, currency) {
    var currencyFormat;
    
    val = (Math.round(val * 100) / 100).toFixed(2);
    
    switch (currency) {
        case 'USD':
            currencyFormat = '$ 0.00';
            val = currencyFormat.replace('0.00', val);
            break;
        case 'EUR':
            currencyFormat = '0,00 €';
            val = value.replace('.', ',');
            val = currencyFormat.replace('0,00', val);
            break;
        default:
            throw new Error('Unknown currency format');
            break;
    }
    return val;
}
</code></pre>

<p><em>More enhanced formatter helper - still with issues</em></p>

<p>Now let us take a closer look on the example above. As you can see we're supporting two currency formats (EUR and USD) now,
which is an enhancement compared to the very simple formatter we saw before but it is still far away from being perfect. Why you may asking?
What happens when our customer wants a shop in the UK? We would have to implement another currency format
in our helper. The solution is very limited regarding to the supported formats &amp; currencies. The code isn't tested in-depth
and we want a solution which can cover all available currency formats. So let us sum up the con's / problems:</p>

<p><strong>tl;dr</strong></p>

<ul>
<li>Dealing with currency formatting on your own is a pain and not recommended</li>
<li>You have to support a bunch of formats and currencies (~ 270 currencies)</li>
<li>Workarounds are necessary to get a somewhat working solution with limitations</li>
<li>The code isn't tested in-depth in different browsers with all the available currency formats</li>
</ul>

<p>What you really want is a Native Browser API which is defined in an ECMAScript specification.</p>

<h3><code>Number.toLocaleString</code> Native Method</h3>

<p>In December 2012, ECMA International published the first edition of ECMA-402, better known as the <a href="http://www.ecma-international.org/ecma-402/1.0/">ECMA
Internationalization API Specification 1.0</a>. This specification
describes an API to bring long overdue localization methods to ECMAScript implementations.</p>

<p>First I stumbled across <code>Number.toLocaleString()</code> in the <a href="https://developer.mozilla.org">Mozilla Developer Network</a>. It
provides you with the ability to format numbers language sensitive.</p>

<pre><code>var num = 3500.99;
num.toLocaleString();
</code></pre>

<p><iframe src="https://jsfiddle.net/klarstil/rkttsyyn/embedded/result/" frameborder="0" width="100%" height="150px"></iframe></p>

<p>If we're taking the example a little bit further and using the <code>language</code> &amp; <code>options</code> arguments, we can format the number
as a currency and format the number the way we want.</p>

<pre><code>var num = 3500.99;
num.toLocaleString('de-DE', {
   style: 'currency',
   currency: 'EUR',
   currencyDisplay: 'name',
   useGrouping: true
});
</code></pre>

<p><iframe src="https://jsfiddle.net/klarstil/mvL6eu7c/embedded/result/" frameborder="0" width="100%" height="150px"></iframe></p>

<h3><code>Intl.NumberFormat</code> Native API</h3>

<p>The <code>Intl.NumberFormat</code> object is a constructor for objects that enables language sensitive number formatting. This is a
great solution for the day-by-day problem we're facing with currency formatting. Especially the <code>options</code> properties <code>currency</code> and
<code>currencyDisplay</code> are very interesting for our use case. Before we're deep diving into the functionality and
ability of the API I would like to take a closer look on the compatibility:</p>

<p><iframe src="//caniuse.bitsofco.de/embed/index.html?feat=internationalization&amp;periods=future_1,current,past_1,past_2" frameborder="0" width="100%" height="390px"></iframe></p>

<p>If your target browser doesn't support the International API specification, there's always a polyfill available on github.
This is the case for the <code>Intl</code> Native API as well: <a href="https://github.com/andyearnshaw/Intl.js/">andyearnshaw/Intl.js/</a>.</p>

<p>Let us take a closer look on how to use the Native API, shall we?</p>

<pre><code>new Intl.NumberFormat([locales[, options]]);
</code></pre>

<p><em>Syntax for <code>Intl.NumberFormat</code></em></p>

<ul>
<li>
<code>locales</code> - Optional argument. A string or an array with a <a href="https://tools.ietf.org/html/rfc5646">BCP 47</a> language tag.
If you omit the parameter the browser's locale will be used.</li>
<li>
<code>options</code> - Optional argument. An object with the following properties:
<ul>
<li>
<code>localeMatcher</code>, <code>style</code>, <code>currency</code>, <code>currencyDisplay</code>, <code>useGrouping</code>, <code>minimumIntegerDigits</code>, <code>minimumFractionDigits</code>, <code>maximumFractionDigits</code>, <code>minimumSignificantDigits</code> &amp; <code>maximumSignificantDigits</code>
</li>
</ul>
</li>
</ul>

<p>For our use case the 3 most important properties inside the <code>options</code> object are: <code>style</code>, <code>currency</code>, <code>currencyDisplay</code>.</p>

<ul>
<li>
<code>style</code> - Defines the style to use for the number formatting. <code>decimal</code> for plain number formatting, <code>currency</code> for
currency formatting &amp; <code>percent</code> for percent formatting.</li>
<li>
<code>currency</code> - The currency to use for currency formatting. Possible values are the <a href="http://www.iso.org/iso/home/standards/currency_codes.htm">ISO 4217</a>
currency codes, such as &quot;USD&quot; for the US dollar, &quot;EUR&quot; for the euro or &quot;GBP&quot; for british pound.</li>
<li>
<code>currencyDisplay</code> - How to display the currency. Possible values are <code>symbol</code> for a localized symbol of the currency,
<code>code</code> to use the ISO currency code or <code>name</code> to use for a localized string of the currency.</li>
</ul>

<pre><code>var number = 123456.789;

// request a currency format
console.log(new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(number));
// 23.456,79 €

// the Japanese yen doesn't use a minor unit
console.log(new Intl.NumberFormat('ja-JP', { style: 'currency', currency: 'JPY' }).format(number));
// ￥123,457
</code></pre>

<p><em>Examples on how to use <code>Intl.NumberFormat</code></em></p>

<h4>Feature detection</h4>

<p>It always comes in handy to know how to detect a certain feature you want to use.</p>

<pre><code>var toLocaleStringSupportsOptions = function() {
    return (typeof Intl == 'object' &amp;&amp; Intl &amp;&amp; typeof Intl.NumberFormat == 'function');
};
</code></pre>

<h3>Performance matters</h3>

<p>After playing around with both approaches, I noticed a quite heavy downside of <code>Number.toLocaleString()</code>. It became a
performance bottleneck with huge data sets. To back up my assumption I've created a benchmark to compare both approaches
and get a number about the operations per second.</p>

<p>Before we dive into the statistics I would like to show off the two approaches we're comparing here:</p>

<p><strong>Number.toLocaleString()</strong></p>

<pre><code>var opts = { style: 'currency', currency: 'EUR' };
12.49.toLocaleString('de-DE', opts);
</code></pre>

<p><strong>Intl.NumberFormat.format()</strong></p>

<pre><code>var opts = { style: 'currency', currency: 'EUR' },
    numberFormat = new Intl.NumberFormat('de-DE', opts);

numberFormat.format(12.49)
</code></pre>

<p>Without further ado here are the results:</p>

<p><img src="/blog/img/stats-currency-formatting.png" alt="Comparison Number.toLocaleString vs. Intl.NumberFormat.format()" /></p>

<p>I highlighted the results of Chrome 58.0.2991, so we can take a closer look on the results.</p>

<p><strong>Chrome 58.0.2991:</strong></p>

<ul>
<li>
<code>Number.toLocaleString()</code> - 7,421 operations per second</li>
<li>
<code>Intl.NumberFormat.format()</code> - 1,659,696 operations per second</li>
</ul>

<p>The other results which I like to point out are the results from Mobile Safari. The benchmark was performed on an iPhone 7 Plus.</p>

<p><strong>Mobile Safari 10.0:</strong></p>

<ul>
<li>
<code>Number.toLocaleString()</code> - 12,683 operations per second</li>
<li>
<code>Intl.NumberFormat.format()</code> - 2,125,766 operations per second</li>
</ul>

<p>Hands down, Mobile Safari is by far the fastest browser regarding the <code>Intl</code> Native API which I found pretty impressive.
On the other hand we tested Chrome Mobile on a Samsung Galaxy S7 with very poor results:</p>

<p><strong>Chrome Mobile 55.0.1882</strong></p>

<ul>
<li>
<code>Number.toLocaleString()</code> - 3,230 operations per second</li>
<li>
<code>Intl.NumberFormat.format()</code> - 265,300 operations per second</li>
</ul>

<h2>Summary</h2>

<p>The Native API <code>Intl.NumberFormat</code> is perfect for heavy client side applications which are dealing with huge data sets
and it is convenient to use. A helper function which uses the API can look like the following code snippet:</p>

<pre><code>function NumberFormatter(locale, opts) {
    var formatNumber,
        defaults = {
            style: 'currency',
            currency: 'EUR'
        };
    opts = opts || {};
    opts = Object.assign({}, defaults, opts);
    
    formatNumber = new Intl.NumberFormat(locale, opts);
    return formatNumber.format;
};

var formatter = new NumberFormatter('de-DE');
console.log(formatter(12.49));
</code></pre>

<p>The <code>Intl</code> API comes with a bunch of other methods for internationalization purposes such as language specific date
formatting.</p>
]]></content>
    </entry>
        <entry>
        <title type="html"><![CDATA[Shopware book for developers]]></title>
        <link href="https://developers.shopware.com/blog/2017/01/26/shopware-book-for-developers"/>
        <updated>2017-01-26T00:00:00+00:00</updated>
        <id>https://developers.shopware.com/blog/2017/01/26/shopware-book-for-developers</id>
        <content type="html"><![CDATA[<div class="alert alert-warning" role="alert">
    The book is available in German only. The title and chapters have been changed for this blog article.
</div>

<p>For all Shopware developers, partners and contributors, there is now comprehensive guide for both working with and contributing to the further development of the software. In cooperation with Shopware’s developer, Daniel Nögel, the popular publishing house, Rheinwerk, recently published “Shopware: The Guide for Developers”. In interview, Daniel Nögel shares what motivated him to undertake this massive project, for whom the book is particularly suitable and where you can buy it.</p>

<h2>How does it feel to finally hold a copy of your Shopware-bestseller in your hands?</h2>

<p>Of course, you have to feel somewhat proud when you can see months of work come together in the finished product. Now I’m simply looking forward to the reader’s feedback. I hope the explanations and descriptions both illuminate aspects of working with Shopware and bring a true added-value to the readers.</p>

<h2>Why does somebody need a Shopware Guide when extensive Shopware Wikis are already available as a resource?</h2>

<p>I believe the Shopware Wikis and book complement one another very well: the book takes the reader more by the hand, step-by-step through development examples. Through several chapters, the book repeatedly addresses a larger project so that both the problems and solutions can be clearly demonstrated. On one hand, this motivates the reader because they can see the complete process of something like writing a plugin for Shopware; on the other, this makes topics more manageable, because the content is explained in a way that the developer can use in their everyday life. For this reason, I can tackle very advanced topics in the book because I’ve already built the foundations with the reader early on.</p>

<p>The strength of the Wikis is that they go in-depth with individual topics. For instance, this makes it possible to present all possible template facets in a concise overview. Wikis are more about providing developers with relevant information on specific topics quickly and comprehensively.</p>

<h2>For whom is this guide particularly suitable?</h2>

<p>I actually had two target groups in mind when writing this book: beginners, who are taking their first steps with Shopware, and experienced users, who are interested in deepening their knowledge about specific topics. These include anything from the new plugin system to more advanced topics like storefront bundles or ElacticSearch. The timing of the book is highly appropriate, since so many innovations came out of Shopware within the past year.</p>

<h2>In your opinion, which chapters/topics are particularly interesting for developers?</h2>

<p>I think the chapter “Shopware behind the scenes” is particularly exciting for advanced developers, because we explain basic concepts that are used in everyday life, but not often examined with deeper thought. “Analyse and understand errors” is also helpful for many developers because, when it comes down to it, not everything goes as planned. In these cases, I think developers are grateful for tips on how to analyse and approach the problem on your own. In general, I think the book is beneficial for all developers because I don’t exclude any topics, and every developer has “blind spots” in certain areas.</p>

<h2>While researching, did you encounter topics that were unfamiliar to you?</h2>

<p>Due to the fact that I’ve been holding developer trainings for a long time, new topics weren’t really an obstacle for me. However, I can admit to being not so talented when it comes to implementing beautiful designs – I’m more inclined to sharing insights to techniques “behind the scenes”. Here I was relieved to have a few colleagues who are far more experienced with the frontend area. And of course, there were a few times when I turned to my colleagues for advice when I wasn’t sure of the best way to present a set of information.</p>

<h2>How much previous experience is required to understand the book?</h2>

<p>Ideally, the reader should have basic programming experience. After all, the book is a guide for working with Shopware and not a general introduction to programming. PHP, MySQL and JavaScript are the most important technologies behind Shopware – if you’re familiar with these, you won’t encounter any problems with the book’s content. However, readers who have experience with other programming languages such as Java or Python should also find the book approachable.</p>

<h2>What is the best way for people to give feedback on the book and discuss the included coding examples?</h2>

<p>We set up a separate area in the Shopware Forum, where readers are encouraged to provide feedback: <a href="https://forum.shopware.com/categories/shopware-das-handbuch-fuer-entwickler">https://forum.shopware.com/categories/shopware-das-handbuch-fuer-entwickler</a></p>

<p>If an example is contrary to what was expected or does not function as planned, the Shopware Forum is the best starting point for addressing any problems. I’m always open to praise and/or criticism – you can best find here on Twitter: <a href="https://twitter.com/danielnoegel">https://twitter.com/danielnoegel</a></p>

<p>The book is available in specialty shops, popular marketplaces as well as <a href="https://www.rheinwerk-verlag.de/shopware_4185/">https://www.rheinwerk-verlag.de/shopware_4185/</a></p>
]]></content>
    </entry>
        <entry>
        <title type="html"><![CDATA[New cart bundle concept]]></title>
        <link href="https://developers.shopware.com/blog/2016/12/09/new-cart-bundle-concept"/>
        <updated>2016-12-09T00:00:00+00:00</updated>
        <id>https://developers.shopware.com/blog/2016/12/09/new-cart-bundle-concept</id>
        <content type="html"><![CDATA[<p>Since the last Community Day, we've received several questions about Shopware's new shopping cart:</p>

<ul>
<li>
<em>How far are you with the development</em>
</li>
<li>
<em>Which new features come with the new shopping cart?</em>
</li>
</ul>

<p>At the Community Day, we also announced that we are striving for open development in the refactoring process in order to get as much feedback as possible and to be able to work more closely with other developers and partners. We want to realize this now by sharing the first concept of the new shopping cart. You can see the development process on <a href="https://github.com/shopware/shopware-cart-poc">Github</a>, where we created a new repository which allows the Community to create pull requests and issues. The new repository contains a new bundle in <code>/engine/Shopware/Bundle/CartBundle</code>, which contains a first proof of concept for a new cart process. This first concept can change steadily due to growing requirements and that refactoring will be an ongoing process. The first features we implemented are the following:</p>

<ul>
<li>Add, delete and change quantity of product line items</li>
<li>Add and delete percentage-based vouchers</li>
<li>First concept for partial delivery</li>
</ul>

<p>There's currently no storefront integration. A view layer will follow after all calculation processes are tested. For that reason, the classes are only used inside unit tests. From a technical perspective, the cart already contains the following concepts/features:</p>

<ul>
<li>Percentage price calculation</li>
<li>Gross and net price calculation</li>
<li>Proportional tax calculation</li>
<li>Exchangeable gateway for product prices and delivery information</li>
<li>First proof of concept for a partial delivery to different addresses and delivery dates</li>
</ul>

<p>If you want to get more information about the technical concept and current implementation, take a look at our <a href="/developers-guide/concept-cart-bundle/" target="_blank">new developers guide article</a>. This article is created to document the current state of the implementation and will contain more content regarding progressive refactoring. Due to the complexity and importance of the shopping cart inside Shopware, this will be a long-term project. Short-term integration into the core product is therefore not to be expected.</p>
]]></content>
    </entry>
        <entry>
        <title type="html"><![CDATA[Large Scale Plugin Architecture]]></title>
        <link href="https://developers.shopware.com/blog/2016/12/05/large-scale-plugin-architecture"/>
        <updated>2016-12-05T00:00:00+00:00</updated>
        <id>https://developers.shopware.com/blog/2016/12/05/large-scale-plugin-architecture</id>
        <content type="html"><![CDATA[<p>Last time I published a post where I was talking about a build system for a new project we were undertaking. After getting a basic project structure and development environment set up we were tasked to create a macro architecture for our software.</p>

<p>In this first part I want to show you how we derived a <em>macroscopic layer structure from technical requirements</em>. The domain structure, and even the service structure will be part of later posts.</p>

<h3>Requirements</h3>

<p>Let me introduce you to the basic requirements we were tasked with:</p>

<blockquote>
<p>&quot;In the following months, and possibly years you will have to create a large scale extension to shopware that exposes a extensible Development Framework, a REST-API, and a end user frontend. Besides creating new entities, simple data containers and dynamic workflows you will furthermore be tasked with problems that are commonly considered <em>hard to implement in Shopware</em>. Although you can initially require a future Shopware release, you might have to support more then one version at a time after release. Oh, and foreign developers might bind to your interfaces, so please create something stable that can still be changed after release. We call it B2B Suite.&quot;</p>
</blockquote>

<p>Woah!! That is a little much.... Maybe... we should start like I started, and break this down into it's various components.</p>

<p>What are the technical components that are required?</p>

<table>
<thead>
<tr>
<th>Type</th>
<th>Targeted Actor</th>
<th>Code stability</th>
</tr>
</thead>
<tbody>
<tr>
<td>REST-API</td>
<td>System Integrator</td>
<td>very stable</td>
</tr>
<tr>
<td>Developer-Framework</td>
<td>Other developers</td>
<td>stable</td>
</tr>
<tr>
<td>Web-Frontend</td>
<td>End users</td>
<td>open</td>
</tr>
</tbody>
</table>

<p>And how complex might the tasks get?</p>

<table>
<thead>
<tr>
<th>Use case</th>
<th>Targeted</th>
<th>Expectation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Simple Entity management</td>
<td>Is a simple use case with an easy implementation. The only caveats here is extensibility.</td>
<td>CRUD</td>
</tr>
<tr>
<td>Complex Workflows</td>
<td>Unknown complex stuff, might not have common solutions.</td>
<td>The real fun :)</td>
</tr>
<tr>
<td>Complex due to Shopware</td>
<td>Should be a simple use case, but is not easily implemented.</td>
<td>Uggly code</td>
</tr>
</tbody>
</table>

<p>So now we have different required parts, learned a little bit about the actors using these parts. And we also gained some insight as to how complex these parts might get.</p>

<p><img src="/blog/img/large-scale-plugin-architecture/reason-to-change.svg" /></p>

<p>So the plugin itself has ties to at least these entities. Each either preventing change from or proclaiming change to the plugins structure. We need to create an architecture that takes this into account. Separating good from bad change and necessary from unnecessary change. In order to accomplish this I want to show you a iterative approach to layer design.</p>

<h3>Iterative Architecture</h3>

<p>We need to gain greater insight into the <strong>The Plugin</strong> thingy. In this chapter I want to define the macro structure of the technical layers based on the components and actor classes defined above. The design goal is to split the responsibilities to change or be static in a meaningful way.</p>

<p>I am a big proponent of <strong>Domain Driven Design</strong> and even more of the ideas behind it. I truely believe that basically anything can be abstracted away apart from the core domain of a application. Using arrays or yaml as config? Who cares! Making changes through REST or CLI. Doesn't matter. Triggering a new order without a shipping address? Deny!</p>

<p>So I believe it is a quite natural starting point to define a domain core precisely handling our use cases / user stories / features / whatever. This core of course has to communicate with the outside world. But does not come with communications means itself. So lets start by drawing a domain core:</p>

<p><img src="/blog/img/large-scale-plugin-architecture/plugin-layer-architecture-1.svg" /></p>

<p>The nice thing about this is that we could start right now constructing business use cases agnostic to I/O transport mechanisms. I usually tend to start working right now and create a few example cases, that are exclusively called through a automated test suite. The UI lives outside of the core so lets add it:</p>

<p><img src="/blog/img/large-scale-plugin-architecture/plugin-layer-architecture-2.svg" /></p>

<p>Most use cases will have to interact with Shopware which is therefore at least on the other side of the core:</p>

<p><img src="/blog/img/large-scale-plugin-architecture/plugin-layer-architecture-3.svg" /></p>

<p>Notice the direction the arrows point, the frontend and REST-API depend on the domain core. That means change for both frontends is inevitable when the core changes. Good! A Change in use case should require a change in I/O. But there is this arrow between Shopware and the domain core. That can not be good.... Obviously Shopware does not depend on our plugin, but does our plugin have to depend on Shopware?</p>

<hr />

<h4>Excurse: The <strong>D</strong> in SOLID: Dependency Inversion Principle</h4>

<p>Polymorphism really is the key to get this right. Instead of depending on the whole and direct implementation of Shopware, we depend on an interface our domain owns that provides just the data access wrapped into our own business objects services.</p>

<p>Let's assume this is our class:</p>

<pre><code class="language-php">class LoginPerformerService {
    public function performLogin(string $email, bool $overwriteExisting = false): My\Identity
    {
        if(!$overwriteExisting &amp;&amp; Shopware()-&gt;Admin()-&gt;sCheckUser()) {
            throw new \DomainException('Would have to overwrite existing identity')
        }

        try {
            $identity = $this-&gt;identityRepository
                    -&gt;fetchIdentityByEmail($email);
        } catch (My\NotFoundException()) {
             $identity = new My\GuestIdentity();
        }

        if(!$identity-&gt;isPersistent()) {
            return $identity;
        }

        Shopware()-&gt;Front()-&gt;Request()-&gt;setParam('password', $identity-&gt;getPassword());
        Shopware()-&gt;Front()-&gt;Request()-&gt;setParam('email', $identity-&gt;getEmail());

        Shopware()-&gt;Admin()-&gt;sLogin();

        Shopware()-&gt;Session()-&gt;offsetSet('my-identity', serialize($identity));

        return $identity;
    }
}
</code></pre>

<p>You see there is a mixed bag of responsibilities from Shopware and from our own code. You might even think this code is reasonably clean, and be correct with it, unless we try to evaluate which lines actually belong to us and which don't. Let me just replace everything that belongs to Shopware with <code>_XX_</code>.</p>

<pre><code class="language-php">class LoginPerformerService {
    public function performLogin(string $email, bool $overwriteExisting = false): My\Identity
    {
        if(!$overwriteExisting &amp;&amp; _XX_) {
            throw new \DomainException('Would have to overwrite existing identity')
        }

        try {
            $identity = $this-&gt;identityRepository
                    -&gt;fetchIdentityByEmail($email);
        } catch (My\NotFoundException()) {
             $identity = new My\GuestIdentity();
        }

        if(!$identity-&gt;isPersistent()) {
            return $identity;
        }

        _XX_
        _XX_

        _XX_

        _XX_

        return $identity;
    }
}
</code></pre>

<p>Turns out five of our statements actually belong to Shopware, so now we can replace them with method calls.</p>

<pre><code class="language-php">class LoginPerformerService {
    public function performLogin(string $email, bool $overwriteExisting = false): My\Identity
    {
        if(!$overwriteExisting &amp;&amp; $this-&gt;shopLogin-&gt;isLoggedIn()) {
            throw new \DomainException('Would have to overwrite existing identity')
        }

        try {
            $identity = $this-&gt;identityRepository
                    -&gt;fetchIdentityByEmail($email);
        } catch (My\NotFoundException()) {
             $identity = new My\GuestIdentity();
        }

        if(!$identity-&gt;isPersistent()) {
            return $identity;
        }

        $this-&gt;shopLogin-&gt;storeLoginOf($identity);

        return $identity;
    }
}
</code></pre>

<p>Create an interface</p>

<pre><code class="language-php">interface ShopLogin {
    public function isLoggedIn(): bool;
    public function storeLoginOf(Identity $identity);
}
</code></pre>

<p>And implement the interface</p>

<pre><code class="language-php">class ShopwareLogin {
   public function isLoggedIn()
   {
        return Shopware()-&gt;Admin()-&gt;sCheckUser();
   }

   public function storeLoginOf(Identity $identity)
   {
        Shopware()-&gt;Front()-&gt;Request()-&gt;setParam('password', $identity-&gt;getPassword());
        Shopware()-&gt;Front()-&gt;Request()-&gt;setParam('email', $identity-&gt;getEmail());

        Shopware()-&gt;Admin()-&gt;sLogin();

        Shopware()-&gt;Session()-&gt;offsetSet('my-identity', serialize($identity));
   }
}

</code></pre>

<p>The obvious trade off is now instead of one class you have to maintain and remember three different classes but there is also a key benefit to this:</p>

<p><strong>Reversed Ownership</strong> From the perspective of the service there is no Shopware, just an interface to call. Your main Domain is secured and our plugin does no longer depend on Shopware, but basically any possible login implementation. This lesson in code also applies to software architecture as a whole. We can reverse the ownership of whole layers by adding one level of indirection.</p>

<hr />

<p>We call it Bridge! A indirection layer between the domain core and Shopware :)</p>

<p><img src="/blog/img/large-scale-plugin-architecture/plugin-layer-architecture-4.svg" /></p>

<p>On paper this may look like a good enough architecture. But Shopware is not just a collection of models and services, but also a really powerful frontend framework, http abstraction layer, template engine and so on. And we should harness this power. So we need to integrate the Frontend layers into our application. The most naive approach first:</p>

<p><img src="/blog/img/large-scale-plugin-architecture/plugin-layer-architecture-5.svg" /></p>

<p>Like the initial domain core design the frontends now depend directly on Shopware itself. Although I called this approach naive, it might actually be the correct one for our use case. If the frontends actually only provide a controller and a view component and just use the domain core as the model this might be a good solution. Here we have to think really careful! Where do we want to start mixing HTTP with our application? Will this mix be Shopware + HTTP, or just HTTP and then Shopware?</p>

<p>Depending on the domain of our plugin several other solutions are possible. For example a bridge for both transport layers:</p>

<p><img src="/blog/img/large-scale-plugin-architecture/plugin-layer-architecture-6.svg" /></p>

<p>Or even just one?</p>

<p><img src="/blog/img/large-scale-plugin-architecture/plugin-layer-architecture-7.svg" /></p>

<p>Maybe... Lets's take a look how this works against our actors:</p>

<h3>Reason to change</h3>

<p>So what actor can introduce change into which component?</p>

<table>
<thead>
<tr>
<th>Use case</th>
<th>Shopware</th>
<th>End User</th>
<th>Foreign Developer</th>
<th>System Integrator</th>
<th>Requirement Change</th>
</tr>
</thead>
<tbody>
<tr>
<td>REST-Frontend</td>
<td>-</td>
<td>-</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>REST-Bridge</td>
<td>X</td>
<td>-</td>
<td>X</td>
<td>-</td>
<td>X</td>
</tr>
<tr>
<td>Store Frontend</td>
<td>-</td>
<td>X</td>
<td>X</td>
<td>-</td>
<td>X</td>
</tr>
<tr>
<td>Front-Bridge</td>
<td>X</td>
<td>-</td>
<td>X</td>
<td>-</td>
<td>X</td>
</tr>
<tr>
<td>Domain-Core</td>
<td>-</td>
<td>X</td>
<td>X</td>
<td>-</td>
<td>X</td>
</tr>
<tr>
<td>Shop-Bridge</td>
<td>X</td>
<td>-</td>
<td>X</td>
<td>-</td>
<td>X</td>
</tr>
</tbody>
</table>

<p>And to what components should these actor bind to?</p>

<table>
<thead>
<tr>
<th>Use case</th>
<th>Shopware</th>
<th>End User</th>
<th>Foreign Developer</th>
<th>System Integrator</th>
<th>Requirement Change</th>
</tr>
</thead>
<tbody>
<tr>
<td>REST-Frontend</td>
<td>-</td>
<td>-</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>REST-Bridge</td>
<td>X</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>X</td>
</tr>
<tr>
<td>Store Frontend</td>
<td>-</td>
<td>X</td>
<td>X</td>
<td>-</td>
<td>X</td>
</tr>
<tr>
<td>Front-Bridge</td>
<td>X</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>X</td>
</tr>
<tr>
<td>Domain-Core</td>
<td>-</td>
<td>-</td>
<td>X</td>
<td>-</td>
<td>X</td>
</tr>
<tr>
<td>Shop-Bridge</td>
<td>X</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>X</td>
</tr>
</tbody>
</table>

<p>Congrats! We have an architecture that <strong>channels change</strong> to different layers and provides reasonably stable ready to use interfaces.</p>

<h3>Conclusion</h3>

<p>You might have noticed that up until now we completely omitted any use cases for the plugin. I will return with these in the next installment of this post.</p>

<p>This approach moves Shopware behind the same curtain as every other service. It is as easy to import Shopware into the plugin as it is to import any other framework.</p>

<p>One could argue that singling out reasons to change is over engineering. And depending on the size of the plugin one could win an argument against me. But If you are planing on writing a sufficient amount of code, you should think about your dependencies, not just in terms of code but also of real world actors to create a structure sufficient for you.</p>

<p>The main concern one could therefore have is that an architecture like that encourages the <em><a href="https://en.wikipedia.org/wiki/Not_invented_here">Not invented here syndrome</a></em>, which certainly can be the case. The bridges encourage cherry picking, and it suddenly becomes a conscious and meaningful decision if you want to reuse something provided by Shopware or are more comfortable with deploying your own solution. But this simply is how modern development works. And opening a topic for discussion should hardly be a problem.</p>

<p>I usually always recommend the idea over the implementation. But after developing in this structure for the better part of the past year I see a great deal of long time potential in this type of technical architecture.</p>
]]></content>
    </entry>
        <entry>
        <title type="html"><![CDATA[Promises Part II - Advanced promise patterns]]></title>
        <link href="https://developers.shopware.com/blog/2016/10/27/promises-part-ii-advanced-promise-patterns"/>
        <updated>2016-10-27T00:00:00+00:00</updated>
        <id>https://developers.shopware.com/blog/2016/10/27/promises-part-ii-advanced-promise-patterns</id>
        <content type="html"><![CDATA[<p>In the last blog post, we took a brief look on promises in JavaScript. They are a great way to deal with asynchronous operations and providing you with a great flow control. In this blog post we're taking a closer look on the <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-constructor">Promise API</a> and more sophisticated patterns. If you haven't read the <a href="https://developers.shopware.com/blog/2016/10/12/promises-asynchronous-processes-made-easy/">last blog post</a>, consider reading it first, before you're continuing with this one.</p>

<h2>Convert jQuery promises into standard compatible promises</h2>

<p>I gave you a brief introduction to the <code>Deferred</code> object in jQuery and pointed out that a lot of jQuery's functions are working with promises already. The prime example is the <code>$.ajax()</code> method.</p>

<p>Let's assume we have a function named <code>fetchPost</code> which fetches data from an API endpoint:</p>

<pre><code>function fetchPost(id) {
    id = id || 1;

    return $.ajax({
        'url': 'https://jsonplaceholder.typicode.com/posts/' + id
    });
}

// Call the function and output the response
fetchPost(1).done(function(response) {
    alert(JSON.stringfy(response));
});
</code></pre>

<p><iframe src="https://jsfiddle.net/klarstil/u3sb8785/embedded/result/" frameborder="0" width="100%" height="250px"></iframe></p>

<p><em>Using the jQuery promise implementation</em></p>

<p>We're using <a href="http://api.jquery.com/promise/">jQuery's Promise</a> object to fulfill the promise. Now assume you're doing the transition from jQuery promises to standard compatible promises in your application. It would be very irritating for you and any third party developer to have a mix of both promise implementations in your application to deal with.</p>

<p>You can overcome this issue using <code>Promise.resolve()</code>, which lets you transform a jQuery promise to a standard compatible promise for example:</p>

<pre><code>function fetchPost(id) {
    id = id || 1;
    
    var jQueryPromise = $.ajax({
        'url': 'https://jsonplaceholder.typicode.com/posts/' + id
    });
    
    return Promise.resolve(jQueryPromise);
}

fetchPost(1).then(function(response) {
    alert(JSON.stringify(response));
});
</code></pre>

<p><iframe src="https://jsfiddle.net/klarstil/pa0pg92a/3/embedded/result/" frameborder="0" width="100%" height="250px"></iframe></p>

<p><em>Transforming jQuery promises into standard promises</em></p>

<p>The only difference in the above code is that we're not returning the jQuery promise right away. We're wrapping it in a call of <code>Promise.resolve()</code>. The call returning a promise object that is resolved with the given value which is the AJAX response in this example.</p>

<p>Sometimes you're finding yourself in the position that you don't know if you're dealing with a promise or not. In this case <code>Promise.resolve()</code> can come in handy too.</p>

<p>Let's assume we're working with a lot of numbers, our application uses promises but a third-party library does not. If you don't know what you're dealing with, always use <code>Promise.resolve()</code>:</p>

<pre><code>function getNumber(num) {
    // We don't know if num is a promise or not, so we're calling Promise.resolve() to always return a new promise object.
    return Promise.resolve(num);
}

// Our given value IS NOT a promise
getNumber(10).then(function(num) {
    alert('The number is: ' + num);
});

// Our given value IS a promise
getNumber(Promise.resolve(10)).then(function() {
    alert('The number is: ' + num);
});
</code></pre>

<p><iframe src="https://jsfiddle.net/klarstil/xz18dj0u/embedded/result/" frameborder="0" width="100%" height="250px"></iframe></p>

<p><em>Working with a mixed environment</em></p>

<p>This pattern enables you to use promises throughout your application and use its advantages for a better flow control.</p>

<p>If you want a little more control and want to terminate if a value is a promise you can use this little code snippet:</p>

<pre><code>function isPromise(obj) {
    return !!obj &amp;&amp; (typeof obj === 'object' || typeof obj === 'function') &amp;&amp; typeof obj.then === 'function';
}
</code></pre>

<p>Check out the <a href="https://github.com/then/is-promise">github repository</a> with the full library from <a href="https://github.com/then">@then</a>.</p>

<h2>Parallel &amp; sequential operations</h2>

<p>In the one of the previous example we created a function called <code>fetchPost</code> which fetches a blog post from an API endpoint. Now imagine you want to fetch multiple posts in parallel. We're continuing using this function for the sake of simplicity.</p>

<p>Let's take a look on a parallel operation first. In the following example we're having an array with post IDs we want to fetch:</p>

<pre><code>var postIds = [ 2, 4, 7, 42 ];

Promise.all(items.map(fetchPost)).then(function(results) {
    console.log(results);
});
</code></pre>

<p><iframe src="https://jsfiddle.net/klarstil/o2h20qhq/embedded/result/" frameborder="0" width="100%" height="250px"></iframe></p>

<p><em>Parallel operations using promises</em></p>

<p>In the above example we're using <code>Promise.all()</code> which returns a promise that will be fulfilled when all the returned promises in the given argument have been resolved or rejected. The argument has to be an iterable object such as an array though.</p>

<p>Running a collection of asynchronous operations in sequence takes a little more effort to come by. You have to chain the promises, so each operation doesn't starts until the previous operation has been fulfilled. We're taking the same example as above but this time we're putting it in sequence:</p>

<pre><code>var postIds = [ 2, 4, 7, 42 ];

var sequencePromise = postIds.reduce(function(promise, item) {
    return promise.then(function(results) {
        return fetchPost(item)
            .then(results.push.bind(results))
            .then(function() { return results; });
    });
}, Promise.resolve([]));
    
sequencePromise.then(function(results) {
    console.log(results);
});
</code></pre>

<p><iframe src="https://jsfiddle.net/klarstil/6wtsps6m/embedded/result/" frameborder="0" width="100%" height="250px"></iframe></p>

<p><em>Sequential operations using promises</em></p>

<p>There's a lot of buzz going on in the above example, so let's break it down. <code>Array.reduce()</code> applies a method against an accumulator and each value of the array to reduce it to a single value. The first argument is the callback method, the second one is the initial value. In our case, we're using a new promise object which is fulfilled with an empty array as a value. We're using the initial promise to call the <code>fetchPost()</code>, using the returned promise from the <code>fetchPost</code> method to write back the response of the call to our <code>results</code> array and returning the filled up <code>results</code> array which we defined as the argument of the initial value.</p>

<h2>Error handling</h2>

<p>Sadly we're not living in a perfect world where everything goes well. Sometimes it's like a rollercoaster, you have good days but sometimes everything that can go wrong goes wrong (<a href="https://en.wikipedia.org/wiki/Murphy's_law">Murphy's law</a>) - it's the same when you're coding. Errors can always occur along the way, a server can be offline temporarily or the user simply inputs something wrong.</p>

<p>Exceptions in JavaScript are synchronous which doesn't go along well in an asynchronous operation. We're bringing back the <a href="https://developers.shopware.com/blog/2016/10/12/promises-asynchronous-processes-made-easy/#getting-started-with-promises">workflow diagram</a> in our mind. A promise can have multiple states. It can be pending, fulfilled or rejected. In our case we want to take a closer look on the rejected state - it provides us with the ability to reject a promise when an error occurred.</p>

<p>One of the most useful features of promises is the automatic propagation of errors. However this feature is only useful if errors are correctly propagated up the call stack. If you're writing a promise chain and ignore the <code>reject()</code> method, errors in the chain will be silently ignored which can hide serious bugs in your application:</p>

<pre><code>function random() {
    return new Promise(function(fulfill, reject) {
        if (Math.random() &gt; 0.5) {
            fulfill('Yeah');
        } else {
            throw new Error('Oh no something went wrong');
        }
    });
}

random().then(function(results) {
    alert('Success');
});
</code></pre>

<p><iframe src="https://jsfiddle.net/klarstil/rn62zntv/1/embedded/result/" frameborder="0" width="100%" height="250px"></iframe></p>

<p><em>Error handling with promises - the wrong way</em></p>

<p>As you can see in the above code and playing around with the example, the error will never be reported and silently ignored, which is a worst case scenario. This is the place where the <code>reject()</code> method comes in handy. The modification is very simple but has a huge impact on your application and the propagation of errors. Always make sure you're adding a <code>catch()</code> callback to catch the error.</p>

<pre><code>function random() {
    return new Promise(function(fulfill, reject) {
        if (Math.random() &gt; 0.5) {
            fulfill('Yeah');
        } else {
            reject(new Error('Oh no something went wrong'));
        }
    });
}

random().then(function(results) {
    alert('Success');
}).catch(function(err) {
     alert('Error');
});
</code></pre>

<p><iframe src="https://jsfiddle.net/klarstil/few8L7gm/1/embedded/result/" frameborder="0" width="100%" height="250px"></iframe></p>

<p><em>Error handling with promises - the right way</em></p>

<p>We're switching out the exception with a call of <code>reject()</code> and using the exception as the first argument. Now we can use the benefits of the automatic propagation feature. Returning a promise has the benefit that people can always handle all errors in the same consistent way.</p>

<p>Keep in mind, you can use the <code>Promise.reject()</code> method to create a new promise object with a rejected state and an error instead of instantiating a new promise object:</p>

<pre><code>Promise.reject(new Error('Oh no something went wrong'));
</code></pre>

<p>Here are some brief advices for handling errors in promises:</p>

<ul>
<li>Don't swallow errors in your promise chain. Either handle the error from the promise directly in the chain or return the promise to the caller, so it can be handled elsewhere.</li>
<li>If you're dealing with multiple promise chains use <code>Promise.all()</code> to catch any error which may occur in the chain.</li>
<li>Bubble up errors the promise chain to the caller and consider throwing the exception to trigger the default unhandled error notifications (e.g. <code>window.onerror</code> or the <code>error</code> event in <code>process</code> for example). This is a convenient way to handle errors in your promise chains, especially when you have a generic error handler in your application already.</li>
</ul>

<h2>Passing state</h2>

<p>Sometimes you want to pass around state in your promise chain. A common example is solving relationships between two data sets for example an &quot;n-1&quot; relationship between multiple posts and an author. You want to fetch the post and author asynchronously and render both objects when both operations are fulfilled.</p>

<p>Again, we're using our <code>fetchPost()</code> function to fetch the post from the endpoint. We're adding a new function called <code>fetchAuthor()</code> which fetches the author from the endpoint:</p>

<pre><code>function fetchPost(id) {
     id = id || 1;
    return Promise.resolve($.ajax({
        'url': 'https://jsonplaceholder.typicode.com/posts/' + id
    }));
}

function fetchAuthor(id) {
     id = id || 1;
    return Promise.resolve($.ajax({
        'url': 'https://jsonplaceholder.typicode.com/users/' + id
    }));
}

fetchPost(1).then(function(post) {
    return Promise.all([ post, fetchAuthor(post.userId) ]);
}).then(function(results) {
    var data = {
        'post': results[0],
        'user': results[1]
    };
    
    // Do something with the data...
    console.log(data)
});
</code></pre>

<p><iframe src="https://jsfiddle.net/klarstil/hkm9o9rp/embedded/result/" frameborder="0" width="100%" height="250px"></iframe></p>

<p><em>Passing state around in a promise chain</em></p>

<p>Unfortunately there's no great way to solve this problem, so you're best bet is our old friend <code>Promise.all()</code>. We're building up an array of all the objects we need and waiting for the new promises while we're keeping the existing values (e.g. state).</p>

<p>Calling <code>Promise.all()</code> returns a promise with the post and the author. The promise will be fulfilled once the author has been fetched from the endpoint. We have to use <code>Promise.all()</code> here because returning an array from a <code>then()</code> callback will not wait for all promises in the array to fulfill. The second argument would still have a promise of the author instead of the author's data we're looking for.</p>

<h2>Who will be first?</h2>

<p><code>Promise.race()</code> is an often overlooked feature of the <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-constructor">Promise API</a>. It provides you with the ability to race two promises against each other. This is quite useful for a timeout method for example. Our goal is to create a function <code>delay()</code> which represents the timeout delay and a method <code>timeout()</code> which is, well, the actual timeout. <code>timeout()</code>'s first argument is a promise and the second argument is the timeout time.</p>

<pre><code>function delay(time) {
    return new Promise(function (fulfill) {
        setTimeout(fulfill, time);
    });
}

function timeout(promise, time) {
    return Promise.race([
        promise,
        delay(time).then(function () {
            // When the delay promise will be settled first, we're throwing an exception.
            throw new Error('Operation timed out');
          });
      ]);
}

timeout(fetchPost(1), 500).then(function(post) {
    console.log(post);
});
</code></pre>

<p>Whichever promise settles (fulfills or rejects) first wins the race and determines the result.</p>

<h2>Conclusion</h2>

<p>Promises are an awesome utility to get rid of the &quot;pyramid of doom&quot; and enhance the flow control of your application. The transition from jQuery promises to the standard compatible implementation is quite simple and the additional methods in the API gives us an excellent flexibility to solve common tasks when working with asynchronous operations. The automatic propagation of errors is a powerful feature. It has some pitfalls you can easily overcome when you're using the API correctly.</p>

<p>This blog post rounds up the JavaScript promises series in this blog.</p>
]]></content>
    </entry>
        <entry>
        <title type="html"><![CDATA[Promises - Asynchronous processes made easy]]></title>
        <link href="https://developers.shopware.com/blog/2016/10/12/promises-asynchronous-processes-made-easy"/>
        <updated>2016-10-12T00:00:00+00:00</updated>
        <id>https://developers.shopware.com/blog/2016/10/12/promises-asynchronous-processes-made-easy</id>
        <content type="html"><![CDATA[<h2>Promises - Asynchronous processes made easy</h2>

<p>Javascript developers are knowing the struggle - you're having a bunch of asynchronous processes you have to time and use their results to call other methods. If it comes to XML HTTP requests or the FileReader API - asynchronous methods are everywhere in the JavaScript world. Without a sophisticated architecture you're probably ending up in the well-known &quot;pyramid of doom&quot; or &quot;callback hell&quot;. You're nesting callbacks over callbacks which has a huge impact of the maintainability and adds a lot of dependencies to your code.</p>

<pre><code>step1(function (value1) {
   step2(value1, function(value2) {
       step3(value2, function(value3) {
           step4(value3, function(value4) {
               // Do something with value4
           });
       });
   });
});
</code></pre>

<p><em>Example for a typical &quot;pyramid of doom&quot;</em></p>

<p><code>Promises</code> are a way around this problem. This blog post will take you on a ride to explore how promises are working and how you can use them right away. The goal is to get rid of the &quot;pyramid of doom&quot; and flatten the pyramid like this:</p>

<pre><code>promise.then(step1)
.then(step2)
.then(step3)
.then(step3)
.then(function(value4) {
    // Do something with value4
})
.catch(function(err) {
   // Handle any error from all above steps
});
</code></pre>

<p><em>Example for a promise based approach</em></p>

<h2>Getting started with promises</h2>

<p>The technology is part of the ECMAScript 2015 (ES6) standard. The <code>Promise</code> object is used for asynchronous operations and has four states which are representing the current status of the operation:</p>

<ul>
<li>
<code>pending</code> - initial status, the promise is not <code>fulfilled</code> or <code>rejected</code> at this point</li>
<li>
<code>fulfilled</code> - the operation was successful</li>
<li>
<code>rejected</code> - the operation wasn't successful and an error occurred</li>
<li>
<code>settled</code> - the operation is not <code>fulfilled</code> or <code>rejected</code> and not <code>pending</code> anymore</li>
</ul>

<p>The <code>Promise</code> interface represents a proxy for a value which is not defined / known at the time the promise was initialized. This allows an association of a <code>handler</code> method which will be triggered with the success or failure of an asynchronous operation.</p>

<p>A promise with the status &quot;pending&quot; can be fulfilled with a value from the asynchronous operation or rejected with the occurring error message. Let's take a look on the workflow of a promise:</p>

<p><img src="/blog/img/workflow-promise.png" alt="" /></p>

<p>Once a promise is fulfilled or rejected, it is immutable (e.g. it can never change again).</p>

<h2>Compatibility</h2>

<p>Before we're jumping right into it, I always like to take a look on the compatibility to terminate if it targets our supported browsers and if we can use it today.</p>

<p><iframe src="//caniuse.bitsofco.de/embed/index.html?feat=promises&amp;periods=future_1,current,past_1,past_2" frameborder="0" width="100%" height="407px"></iframe></p>

<p>All of our target browsers are supported but your environment probably looks different than ours. No worries, there are polyfills out there which can provide you with the missing functionality. Here are a few:</p>

<p><strong>Browser / Node.js:</strong></p>

<ul>
<li>
<a href="https://github.com/stefanpenner/es6-promise">https://github.com/stefanpenner/es6-promise</a>
</li>
<li>
<a href="https://github.com/taylorhakes/promise-polyfill">https://github.com/taylorhakes/promise-polyfill</a>
</li>
<li>
<a href="https://github.com/lahmatiy/es6-promise-polyfill">https://github.com/lahmatiy/es6-promise-polyfill</a>
</li>
<li>
<a href="https://github.com/then/promise">https://github.com/then/promise</a>
</li>
</ul>

<p>If you're using jQuery version 1.5 or newer you don't even have to worry about polyfilling promises - it comes with its own implementation but more on this later on.</p>

<h2>Constructing a promise</h2>

<p>Imagine we're having a function which sends an XML HTTP request using <code>GET</code> to request and receive data from the server.</p>

<pre><code>function getData(url, callback) {
    var req = new XMLHttpRequest();
    
    req.open('GET', url);
    
    req.onload = function() {
        if (req.status !== 200) {
            callback(new Error(&quot;Status code wasn't 200&quot;), null);
            return;
        }
        
        callback(null, req.response);
    }
    
    req.onerror = function() {
        callback(new Error(&quot;Network error&quot;), null);
    }
    
    req.send();
}

// A typical call looks like this
getData('product.json', function(err, result) {
       if (err) {
           console.error('Failed!', err);
           return false;
       }
       
       console.log('Success!', result)
});
</code></pre>

<p>In the above example I'm using a callback based approach to solve the problem to handle an asynchronous operation like requesting data from the server. Before we're transforming this code into a promise I would like to show off the basic syntax of a promise:</p>

<pre><code>new Promise(executor);

// e.g.
new Promise(function(fulfill, reject) { ... });
</code></pre>

<ul>
<li>
<p><strong>executor</strong></p>
<ul>
<li>The <code>executor</code> is a function with the two arguments <code>fulfill</code> and <code>reject</code>. The first argument computes the promise, the second one discards the promise.</li>
</ul>
</li>
</ul>

<p>Now we know how a promise works and how the syntax looks like, let's promisify the above example:</p>

<pre><code>// We removed the callback parameter cause we don't need it anymore
function getData(url) {
    
    // Return a new promise and wrap the previous logic into the anonymous function
    return new Promise(function(fulfill, reject) {
        var req = new XMLHttpRequest();
    
        req.open('GET', url);
        
        req.onload = function() {
            if (req.status !== 200) {
                // Instead of the callback we're calling the reject callback of the promise
                reject(new Error(&quot;Status code wasn't 200&quot;));
                return;
            }
            
            // Everything was fine, so we can fulfill the promise
            fulfill(req.response);
        }
        
        req.onerror = function() {
            // We're rejecting the promise here cause an error occured
            reject(new Error(&quot;Network error&quot;));
        }
        
        req.send();
    });
    
}

// A typical call looks like this
getData('product.json').then(function(result) {
    console.log('Success!', result)
}, function(err) {
    console.error('Failed!', err);
});

// ...or you can use catch to handle the errors
getData('product.json').then(function(result) {
    console.log('Success!', result)
}).catch(function(err) {
    console.error('Failed!', err);
});
</code></pre>

<p>As you can see in the code example it is very easy to remove the callback approach and replace it with a promise. Basically we're wrapping our logic into a new promise and replace the callback calls with a call of either the <code>fulfill</code> or <code>reject</code> method.</p>

<h2>Queuing asynchronous operation</h2>

<p>You can also chain <code>then()</code> calls to run asynchronous operation in sequence. If you return a promise in a <code>then()</code>, the next <code>then()</code> will be called with the returned promise, which can be used to enable chaining operations:</p>

<pre><code>getData('product.json').then(function(product) {
    return getData(product.productDetailsUrl);
}).then(function(productDetails) {
    console.log('Do something with the product details');
});
</code></pre>

<p>It's looks like magic but works wonderful. Error handling can be added by simply adding a <code>catch()</code> call to the function chain. The <code>catch()</code> method will be triggered if one of the promises gets rejected.</p>

<h2>Promises with callbacks - best of both worlds with <code>Q</code></h2>

<p><a href="https://github.com/kriskowal/q">Q</a> is a popular JavaScript Promise library which I personally use in <a href="https://nodejs.org/en/">Node.js</a>. Node.js methods are usually asynchronous unless you're using the synchronous version of the method which isn't the best idea. Therefore you're having a bunch of callbacks in your code / module and every third party developers assumes you're working with callbacks as well.</p>

<p>One of the benefits of <code>Q</code> is that you can provide a promise and support the callback approach at the same time. In the following example we're creating a method which concatenates the firstname and lastname of a user:</p>

<pre><code>var Q = require('q');

module.exports = {
    getFullName: function (firstName, lastName, callback) {
        var deferred = Q.defer();

        if (firstName &amp;&amp; lastName) {
            var fullName = firstName + &quot; &quot; + lastName;
            deferred.resolve(fullName);
        }
        else {
            deferred.reject(&quot;First and last name must be passed.&quot;);
        }

        deferred.promise.nodeify(callback);
        return deferred.promise;
    }
}
</code></pre>

<p>You can use the promise or the callback whatever floats your boat:</p>

<pre><code>nameModule.getFullName('John', 'Doe').then(function(fullName) {
    console.log(fullName)
}).fail(function(err) {
    console.error(err);
});
</code></pre>

<p>...or using a callback approach:</p>

<pre><code>nameModule.getFullName('John', 'Doe', function(err, fullName) {
    if (err) {
        console.error(err);
        return false;
    }
    
    console.log(fullName);
});
</code></pre>

<p>The magic in the above code is the call of <code>deferred.promise.nodeify(callback)</code>. It automatically assumes it's a Node.js-style callback and calls it as either <code>callback(err, null)</code> with the provided error when the promise was rejected or <code>callback(null, result)</code> when the promise becomes fulfilled. If callback is not a function, it simply returns the promise.</p>

<h2>jQuery - promises and deferred functions</h2>

<p>jQuery 1.5 introduced the <a href="http://api.jquery.com/category/deferred-object/">Deferred</a> object which provides a way to register multiple callbacks into self-managed callback queues, invoke callback queues as appropriate, and relay the success or failure state of any synchronous or asynchronous function. The Promise object is a subset of the methods from the Deferred object and prevents the user from changing the state of the Deferred, so it's immutable.</p>

<p>Enough theory, let's take a look on an actual code example. We'll create timers which will be using promises. Let's take a look on one of the usual ways to solve the problem:</p>

<pre><code>var waitingTimer = function(time, notify, callback) {
    var timer;

    // Make sure our values are defined.
    time = time || 10000;
    callback = callback || function() {};
    notify = notify || function() {};
    
    timer = window.setInterval(function() {
        notify.apply(null);
    }, 1000);
    
    window.setTimeout(function() {
        window.clearInterval(timer);
        cb.apply(null);
    }, time);
};
</code></pre>

<p>The above code can be used like that:</p>

<pre><code>$('button').on('click', function() {
    var $waitingTimer = $('.waiting-timer');
    
    waitingTimer(5000, function() {
        $waitingTimer.html($waitingTimer.html() + &quot;.&quot;);
      }, function() {
        $waitingTimer.html(&quot;Done!&quot;);
      });
});
</code></pre>

<p><iframe src="https://jsfiddle.net/klarstil/m1p89frr/1/embedded/result/" frameborder="0" width="100%" height="250px"></iframe></p>

<p>Now let us promisify the above code:</p>

<pre><code>var waitingTimer = function(time) {
    
    // Get the global deferred object
    var deferred = $.Deferred(),
        timer;

    // Make sure our values are defined.
    time = time || 10000;
    
    timer = window.setInterval(function() {
        // Fire the notify method on the deferred object
        deferred.notify();
    }, 1000);
    
    window.setTimeout(function() {
        window.clearInterval(timer);
        
        // Resolve the promise
        deferred.resolve();
    }, time);
    
    // We're returning the promise at that point
    return deferred.promise();
};
</code></pre>

<p>The promisify code can be used like that:</p>

<pre><code>$('button').on('click', function() {
    var $waitingTimer = $('.waiting-timer');
    
    waitingTimer(5000).progress(function() {
        $waitingTimer.html($waitingTimer.html() + &quot;.&quot;);
      }).done(function() {
        $waitingTimer.html(&quot;Done!&quot;);
    });
});
</code></pre>

<p><iframe src="https://jsfiddle.net/klarstil/jwbxt71j/embedded/result/" frameborder="0" width="100%" height="250px"></iframe></p>

<p>As a side note: Quite a few jQuery methods are using promises or the Deferred object already. One of the most common one is <code>$.ajax()</code> which allows to use a promise instead of callback methods:</p>

<pre><code>$.ajax({
    url: &quot;/ServerResource.txt&quot;
}).done(result, function(result) {
    console.log(&quot;Success!&quot;, result);
}).fail(function(err) {
    console.error('Failed!', err);
});
</code></pre>

<p>jQuery uses the <a href="http://wiki.commonjs.org/wiki/Promises/A">CommonJS Promises/A interface</a> for the jQuery XMLHttpRequest.</p>

<p>There's just one downside you have to consider when working with promises or the Deferred object. jQuery's promises are linked to a Deferred object stored on the <code>.data()</code> for an element. Since the <code>.remove()</code> method removes the element's data as well as the element itself, it will prevent any of the element's unresolved Promises from resolving.</p>

<h2>Conclusion</h2>

<p>Promises are looking like a brand new technology but apparently they are not. jQuery introduced them with version 1.5 which was released back in 2011. They provide a great and easy to use way to overcome the problem of having nesting callbacks in your application. As we saw in the blog post it's very easy to transform your callback code into a promised based approach which provides a higher flexibility and an easier maintainable code base.</p>

<p>The compatibility is great, there are a lot of polyfills out there and the fact that jQuery comes with an own implementation of promises and deferred functions let me think, that there's no reason not to use promises now.</p>

<p>We went over the basics on what you can do with promises. There are a bunch of different methods in the offical standard which allow you to do much more advanced things. We'll cover them in one of the next blog posts.</p>
]]></content>
    </entry>
        <entry>
        <title type="html"><![CDATA[How we handle the quality assurance process]]></title>
        <link href="https://developers.shopware.com/blog/2016/10/06/how-we-handle-the-quality-assurance-process"/>
        <updated>2016-10-06T00:00:00+00:00</updated>
        <id>https://developers.shopware.com/blog/2016/10/06/how-we-handle-the-quality-assurance-process</id>
        <content type="html"><![CDATA[<p>Since I often get questions regarding our development workflow here at Shopware, this entire post is devoted to giving you a
little more insight into our quality assurance (QA) process.</p>

<p>As a software company, we try to cover the whole development process in an agile culture, and since the majority of our teams are using Scrum or Kanban, we try to strictly follow the <a href="http://agilemanifesto.org/" target="_blank">agile manifesto</a>. However, in an agile environment, it’s sometimes difficult to fluently integrate the quality assurance process.</p>

<p>Before I go into what works well, let me share an attitude that doesn’t work at all: &quot;We don't need extra testers. Tell the developers they can take more time developing and testing things by themselves, but they have to stop creating bugs.&quot;</p>

<p>I don’t think I need to explain why this statement is completely counterproductive, and I’m glad this viewpoint never found its way to Shopware.</p>

<p>Similar to other IT companies, our development and QA teams worked separately.</p>

<p><img src="/blog/img/qa_at_speed0.png" alt="" /></p>

<p>You might be familiar with the situation in which several tickets often stuck in the QA phase and the entire development processes seems to stop – this is just one of the problems you face when you have this kind of workflow.</p>

<p>That was until a few months ago when I came across an approach developed and used by Atlassian:</p>

<p><a href="https://de.atlassian.com/agile/how-to-deliver-quality-assurance-at-speed-video" target="_blank">How to deliver quality assurance at speed</a>.</p>

<p>At first I was skeptical because the aforementioned attitude came to my mind. But the more I thought about it, the more it grew on me. After deciding to present the idea to the team, I was surprised to find nearly everyone was on board. So together we decided to give it a try.</p>

<p>Now at this point – and if you haven’t already done so – I highly recommend checking out the video cast from Atlassian.</p>

<h1>Dotting</h1>

<p>About a week later we started working with the following workflow:</p>

<p><img src="/blog/img/qa_at_speed1.png" alt="" /></p>

<p>In this scenario, a different developer tests the work of his colleague. After the code review, the tester and developer meet and discuss what the DOT (developer on test) needs to test (demo). An important point of this discussion is to speak about potential risks and testing notes; they should always open questions rather than create a list of click scenarios.</p>

<p>For example: What about the full page cache? What if we use https instead off http?</p>

<p>This allows the developer to learn directly from the experience of the tester. The main goal of this entire approach is to teach the developers how to run tests.
After the demo, the DOTs begin the actual testing. Before the software is released, there is always an additional testing phase run by the testers.
This is done because of two reasons:
first, to have a safety net if the DOTs didn't catch every bug; second, to evaluate the testing quality of the DOTs.</p>

<h2>Problems</h2>

<p>After a few days we faced a couple of issues, which led us to change the workflow again.</p>

<p>The problems were:</p>

<ul>
<li>The developers selected as the DOTs were often the same colleagues, which made the experience unevenly distributed.</li>
<li>Suddenly the new process was even slower than the process before, because several developers either forgot or postponed their tasks as a DOT. This left the status of many tickets unchanged.</li>
<li>The author of a ticket didn't feel responsible for the quality, considering it would eventually fall into the hands of a DOT.</li>
</ul>

<h1>Our current workflow</h1>

<p>After this experience, we felt brave enough to go on with the last phase explained in the video.</p>

<p><img src="/blog/img/qa_at_speed2.png" alt="" /></p>

<p>Before a developer starts working on a ticket, he comes together with QA for a kickoff meeting. The point of this meeting is to discuss any risks or important aspects to keep in mind while developing. This is a preventative measure for avoiding bugs before they even exist. After this discussion, the developer starts to code and runs tests at the same time.</p>

<p>After coding/testing, the developer and QA run a normal demo, speak about what has already been tested and try to locate any missing scenarios. The developer then tests the missing scenarios independently so that he knows what to consider in the future.</p>

<p>During the next step, which is a normal code review, an additional developer takes a look at the code. If there is nothing to complain about, the code it merged and the ticket closed. Should the reviewer discover any larger structural problems, the developer is responsible for fixing them and the process goes back to step one with an initial demo meeting.</p>

<p>Before every release, QA performs a release test to make sure everything runs smoothly. Around 5-8% of the tickets in the release still contain a problem of some nature (referred to as “rejection rate”). It is very important to measure this value, because it’s your only indicator for finding out if the ability of your developers to run tests has improved.</p>

<p>In the future, when the testing skills of your developers equal the skills of your QA, you can consider completely removing the safety net.</p>

<p>By the way: when we started with this process, our rejection rate was around 30-40%. It’s safe to say this approach worked extraordinarily well for our team.</p>

<h1>Conclusion</h1>

<p>One of the best features of this approach is that you no longer have anything blocking this workflow. For this reason, the development process is significantly faster. It also scales perfectly with the number of developers; an ideal advantage for a company that’s quickly expanding.</p>

<p>Because our rejection rate is 5-8% – and we don’t want to take the risk of releasing software with bugs – we have a little way to go before we get rid of this safety net. But we analyze this statistic in every sprint to measure our improvement.</p>

<p>Of course, this workflow isn’t applicable for every team or situation. But for agile environments, it’s especially important to try new things, constantly improve and find the workflow which fits bests for your team.</p>
]]></content>
    </entry>
    </feed>